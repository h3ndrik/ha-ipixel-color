/**
 * BDF Parser Bundle for ha-ipixel-color
 * Combines bdfparser (v2.2.5) and fetchline (v1.0.1) from jsDelivr CDN
 *
 * Sources:
 * - bdfparser: https://github.com/tomchen/bdfparser-js
 * - fetchline: https://github.com/nicehunter/fetchline
 */

// ============= fetchline (v1.0.1) =============
var fetchline_e=function(e,n,t,r){return new(t||(t=Promise))((function(o,i){function c(e){try{l(r.next(e))}catch(e){i(e)}}function u(e){try{l(r.throw(e))}catch(e){i(e)}}function l(e){var n;e.done?o(e.value):(n=e.value,n instanceof t?n:new t((function(e){e(n)}))).then(c,u)}l((r=r.apply(e,n||[])).next())}))},fetchline_n=function(e){return this instanceof fetchline_n?(this.v=e,this):new fetchline_n(e)},fetchline_t=function(e,t,r){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var o,i=r.apply(e,t||[]),c=[];return o={},u("next"),u("throw"),u("return"),o[Symbol.asyncIterator]=function(){return this},o;function u(e){i[e]&&(o[e]=function(n){return new Promise((function(t,r){c.push([e,n,t,r])>1||l(e,n)}))})}function l(e,t){try{(r=i[e](t)).value instanceof fetchline_n?Promise.resolve(r.value.v).then(s,a):f(c[0][2],r)}catch(e){f(c[0][3],e)}var r}function s(e){l("next",e)}function a(e){l("throw",e)}function f(e,n){e(n),c.shift(),c.length&&l(c[0][0],c[0][1])}};

function $fetchline(r,{includeLastEmptyLine:o=!0,encoding:i="utf-8",delimiter:c=/\r?\n/g}={}){return fetchline_t(this,arguments,(function*(){const t=yield fetchline_n((n=>fetchline_e(void 0,void 0,void 0,(function*(){const e=yield fetch(n);if(null===e.body)throw new Error("Cannot read file");return e.body.getReader()})))(r));let{value:u,done:l}=yield fetchline_n(t.read());const s=new TextDecoder(i);let a,f=u?s.decode(u):"";if("string"==typeof c){if(""===c)throw new Error("delimiter cannot be empty string!");a=new RegExp(c.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&"),"g")}else a=!1===/g/.test(c.flags)?new RegExp(c.source,c.flags+"g"):c;let d=0;for(;;){const e=a.exec(f);if(null!==e)yield yield fetchline_n(f.substring(d,e.index)),d=a.lastIndex;else{if(!0===l)break;const e=f.substring(d);({value:u,done:l}=yield fetchline_n(t.read())),f=e+(f?s.decode(u):""),d=0}}(o||d<f.length)&&(yield yield fetchline_n(f.substring(d)))}))}

// ============= bdfparser (v2.2.5) =============
var t=function(t,e,n,r){return new(n||(n=Promise))((function(i,s){function a(t){try{l(r.next(t))}catch(t){s(t)}}function o(t){try{l(r.throw(t))}catch(t){s(t)}}function l(t){var e;t.done?i(t.value):(e=t.value,e instanceof n?e:new n((function(t){t(e)}))).then(a,o)}l((r=r.apply(t,e||[])).next())}))},e=function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e,n=t[Symbol.asyncIterator];return n?n.call(t):(t="function"==typeof __values?__values(t):t[Symbol.iterator](),e={},r("next"),r("throw"),r("return"),e[Symbol.asyncIterator]=function(){return this},e);function r(n){e[n]=t[n]&&function(e){return new Promise((function(r,i){(function(t,e,n,r){Promise.resolve(r).then((function(e){t({value:e,done:n})}),e)})(r,i,(e=t[n](e)).done,e.value)}))}}};const n="[\\s]+",r={glyphname:"empty",codepoint:8203,bbw:0,bbh:0,bbxoff:0,bbyoff:0,swx0:0,swy0:0,dwx0:0,dwy0:0,swx1:0,swy1:0,dwx1:0,dwy1:0,vvectorx:0,vvectory:0,hexdata:[]},i=["glyphname","codepoint","bbw","bbh","bbxoff","bbyoff","swx0","swy0","dwx0","dwy0","swx1","swy1","dwx1","dwy1","vvectorx","vvectory","hexdata"],s={lr:"lrtb",rl:"rltb",tb:"tbrl",bt:"btrl",lrtb:void 0,lrbt:void 0,rltb:void 0,rlbt:void 0,tbrl:void 0,tblr:void 0,btrl:void 0,btlr:void 0},a={lr:1,rl:2,tb:0,bt:-1};class o{constructor(){this.headers=void 0,this.__headers={},this.props={},this.glyphs=new Map,this.__glyph_count_to_check=null,this.__curline_startchar=null,this.__curline_chars=null}load_filelines(n){var r,i;return t(this,void 0,void 0,(function*(){try{this.__f=n,yield this.__parse_headers()}finally{if("undefined"!=typeof Deno&&void 0!==this.__f)try{for(var t,s=e(this.__f);!(t=yield s.next()).done;){t.value}}catch(t){r={error:t}}finally{try{t&&!t.done&&(i=s.return)&&(yield i.call(s))}finally{if(r)throw r.error}}}return this}))}__parse_headers(){var e,r;return t(this,void 0,void 0,(function*(){for(;;){const t=null===(r=yield null===(e=this.__f)||void 0===e?void 0:e.next())||void 0===r?void 0:r.value,i=t.split(/ (.+)/,2),s=i.length;let a;if(2===s){const e=i[0],r=i[1].trim();switch(e){case"STARTFONT":this.__headers.bdfversion=parseFloat(r);break;case"FONT":this.__headers.fontname=r;break;case"SIZE":a=r.split(" "),this.__headers.pointsize=parseInt(a[0],10),this.__headers.xres=parseInt(a[1],10),this.__headers.yres=parseInt(a[2],10);break;case"FONTBOUNDINGBOX":a=r.split(" "),this.__headers.fbbx=parseInt(a[0],10),this.__headers.fbby=parseInt(a[1],10),this.__headers.fbbxoff=parseInt(a[2],10),this.__headers.fbbyoff=parseInt(a[3],10);break;case"STARTPROPERTIES":return this.__parse_headers_after(),void(yield this.__parse_props());case"COMMENT":"comment"in this.__headers&&Array.isArray(this.__headers.comment)||(this.__headers.comment=[]),this.__headers.comment.push(r.replace(/^[\s"'\t\r\n]+|[\s"'\t\r\n]+$/g,""));break;case"SWIDTH":a=r.split(" "),this.__headers.swx0=parseInt(a[0],10),this.__headers.swy0=parseInt(a[1],10);break;case"DWIDTH":a=r.split(" "),this.__headers.dwx0=parseInt(a[0],10),this.__headers.dwy0=parseInt(a[1],10);break;case"SWIDTH1":a=r.split(" "),this.__headers.swx1=parseInt(a[0],10),this.__headers.swy1=parseInt(a[1],10);break;case"DWIDTH1":a=r.split(" "),this.__headers.dwx1=parseInt(a[0],10),this.__headers.dwy1=parseInt(a[1],10);break;case"VVECTOR":a=n.split(r),this.__headers.vvectorx=parseInt(a[0],10),this.__headers.vvectory=parseInt(a[1],10);break;case"METRICSSET":case"CONTENTVERSION":this.__headers[e.toLowerCase()]=parseInt(r,10);break;case"CHARS":return console.warn("It looks like the font does not have property block beginning with 'STARTPROPERTIES' keyword"),this.__parse_headers_after(),this.__curline_chars=t,void(yield this.__parse_glyph_count());case"STARTCHAR":return console.warn("It looks like the font does not have property block beginning with 'STARTPROPERTIES' keyword"),console.warn("Cannot find 'CHARS' line"),this.__parse_headers_after(),this.__curline_startchar=t,void(yield this.__prepare_glyphs())}}if(1===s&&"ENDFONT"===i[0].trim())return console.warn("It looks like the font does not have property block beginning with 'STARTPROPERTIES' keyword"),void console.warn("This font does not have any glyphs")}}))}__parse_headers_after(){"metricsset"in this.__headers||(this.__headers.metricsset=0),this.headers=this.__headers}__parse_props(){var e,n;return t(this,void 0,void 0,(function*(){for(;;){const t=(null===(n=yield null===(e=this.__f)||void 0===e?void 0:e.next())||void 0===n?void 0:n.value).split(/ (.+)/,2),r=t.length;if(2===r){const e=t[0],n=t[1].replace(/^[\s"'\t\r\n]+|[\s"'\t\r\n]+$/g,"");"COMMENT"===e?("comment"in this.props&&Array.isArray(this.props.comment)||(this.props.comment=[]),this.props.comment.push(n.replace(/^[\s"'\t\r\n]+|[\s"'\t\r\n]+$/g,""))):this.props[e.toLowerCase()]=n}else if(1===r){const e=t[0].trim();if("ENDPROPERTIES"===e)return void(yield this.__parse_glyph_count());if("ENDFONT"===e)return void console.warn("This font does not have any glyphs");this.props[e]=null}}}))}__parse_glyph_count(){var e,n;return t(this,void 0,void 0,(function*(){let t;if(null===this.__curline_chars?t=null===(n=yield null===(e=this.__f)||void 0===e?void 0:e.next())||void 0===n?void 0:n.value:(t=this.__curline_chars,this.__curline_chars=null),"ENDFONT"===t.trim())return void console.warn("This font does not have any glyphs");const r=t.split(/ (.+)/,2);"CHARS"===r[0]?this.__glyph_count_to_check=parseInt(r[1].trim(),10):(this.__curline_startchar=t,console.warn("Cannot find 'CHARS' line next to 'ENDPROPERTIES' line")),yield this.__prepare_glyphs()}))}__prepare_glyphs(){var e,r;return t(this,void 0,void 0,(function*(){let t=0,i=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],s=[],a=!1,o=!1;for(;;){let l;if(null===this.__curline_startchar?l=null===(r=yield null===(e=this.__f)||void 0===e?void 0:e.next())||void 0===r?void 0:r.value:(l=this.__curline_startchar,this.__curline_startchar=null),null==l)return console.warn("This font does not have 'ENDFONT' keyword"),void this.__prepare_glyphs_after();const h=l.split(/ (.+)/,2),c=h.length;if(2===c){const e=h[0],r=h[1].trim();let s;switch(e){case"STARTCHAR":i=[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],i[0]=r,o=!1;break;case"ENCODING":t=parseInt(r,10),i[1]=t;break;case"BBX":s=r.split(" "),i[2]=parseInt(s[0],10),i[3]=parseInt(s[1],10),i[4]=parseInt(s[2],10),i[5]=parseInt(s[3],10);break;case"SWIDTH":s=r.split(" "),i[6]=parseInt(s[0],10),i[7]=parseInt(s[1],10);break;case"DWIDTH":s=r.split(" "),i[8]=parseInt(s[0],10),i[9]=parseInt(s[1],10);break;case"SWIDTH1":s=r.split(" "),i[10]=parseInt(s[0],10),i[11]=parseInt(s[1],10);break;case"DWIDTH1":s=r.split(" "),i[12]=parseInt(s[0],10),i[13]=parseInt(s[1],10);break;case"VVECTOR":s=n.split(r),i[14]=parseInt(s[0],10),i[15]=parseInt(s[1],10)}}else if(1===c){const e=h[0].trim();switch(e){case"BITMAP":s=[],a=!0;break;case"ENDCHAR":a=!1,i[16]=s,this.glyphs.set(t,i),o=!0;break;case"ENDFONT":if(o)return void this.__prepare_glyphs_after();default:a&&s.push(e)}}}}))}__prepare_glyphs_after(){const t=this.glyphs.size;this.__glyph_count_to_check!==t&&(null===this.__glyph_count_to_check?console.warn("The glyph count next to 'CHARS' keyword does not exist"):console.warn(`The glyph count next to 'CHARS' keyword is ${this.__glyph_count_to_check.toString()}, which does not match the actual glyph count ${t.toString()}`))}get length(){return this.glyphs.size}itercps(t,e){const n=null!=t?t:1,r=null!=e?e:null;let i;const s=[...this.glyphs.keys()];switch(n){case 1:i=s.sort(((t,e)=>t-e));break;case 0:i=s;break;case 2:i=s.sort(((t,e)=>e-t));break;case-1:i=s.reverse()}if(null!==r){const t=t=>{if("number"==typeof r)return t<r;if(Array.isArray(r)&&2===r.length&&"number"==typeof r[0]&&"number"==typeof r[1])return t<=r[1]&&t>=r[0];if(Array.isArray(r)&&Array.isArray(r[0]))for(const e of r){const[n,r]=e;if(t<=r&&t>=n)return!0}return!1};i=i.filter(t)}return i}*iterglyphs(t,e){for(const n of this.itercps(t,e))yield this.glyphbycp(n)}glyphbycp(t){const e=this.glyphs.get(t);if(null==e)return console.warn(`Glyph "${String.fromCodePoint(t)}" (codepoint ${t.toString()}) does not exist in the font. Will return 'null'`),null;{const t={};return i.forEach(((n,r)=>{var i,s,a;i=t,s=n,a=e[r],i[s]=a})),new l(t,this)}}glyph(t){const e=t.codePointAt(0);return void 0===e?null:this.glyphbycp(e)}lacksglyphs(t){const e=[],n=t.length;for(let r,i=0;i<n;i++){r=t[i];const n=r.codePointAt(0);void 0!==n&&this.glyphs.has(n)||e.push(r)}return 0!==e.length?e:null}drawcps(t,e={}){var n,i,o,c,d,_,p;const u=null!==(n=e.linelimit)&&void 0!==n?n:512,f=null!==(i=e.mode)&&void 0!==i?i:1,b=null!==(o=e.direction)&&void 0!==o?o:"lrtb",y=null!==(c=e.usecurrentglyphspacing)&&void 0!==c&&c,g=null!==(d=e.missing)&&void 0!==d?d:null;if(void 0===this.headers)throw new Error("Font is not loaded");let v,w,m,I,S,k,x,T,E,A,R,N,O,D,P,C,$,H;const M=null!==(_=s[b])&&void 0!==_?_:b,F=M.slice(0,2),W=M.slice(2,4);F in a&&W in a?(k=a[F],x=a[W]):(k=1,x=0),0===x||2===x?v=1:1!==x&&-1!==x||(v=0),1===k||-1===k?w=1:2!==k&&0!==k||(w=0),1===f&&(T=k>0?this.headers.fbbx:this.headers.fbby,k>0?(N="dwx0",O="dwy0"):(N="dwx1",O="dwy1"),R=N in this.headers?this.headers[N]:O in this.headers?this.headers[O]:null);const j=[];I=[];const B=[];P=[],C=0;const G=()=>{j.push(I),y?P.shift():P.pop(),B.push(P)},V=t[Symbol.iterator]();for($=!1;;){if($)$=!1;else{if(S=null===(p=V.next())||void 0===p?void 0:p.value,void 0===S)break;const t=this.glyphbycp(S);E=null!==t?t:g?g instanceof l?g:new l(g,this):new l(r,this),m=E.draw(),H=m.width(),D=0,1===f&&void 0!==N&&void 0!==O&&(A=E.meta[N]||E.meta[O],null==A&&(A=R),null!=A&&void 0!==T&&(D=A-T))}if(void 0!==H&&void 0!==D&&void 0!==m&&void 0!==E&&void 0!==S)if(C+=H+D,C<=u)I.push(m),P.push(D);else{if(0===I.length)throw new Error(`\`_linelimit\` (${u}) is too small the line can't even contain one glyph: "${E.chr()}" (codepoint ${S}, width: ${H})`);G(),C=0,I=[],P=[],$=!0}}0!==I.length&&G();const z=j.map(((t,e)=>h.concatall(t,{direction:k,align:v,offsetlist:B[e]})));return h.concatall(z,{direction:x,align:w})}draw(t,e={}){const{linelimit:n,mode:r,direction:i,usecurrentglyphspacing:s,missing:a}=e;return this.drawcps(t.split("").map((t=>{const e=t.codePointAt(0);return void 0===e?8203:e})),{linelimit:n,mode:r,direction:i,usecurrentglyphspacing:s,missing:a})}drawall(t={}){const{order:e,r:n,linelimit:r,mode:i,direction:s,usecurrentglyphspacing:a}=t,o=null!=i?i:0;return this.drawcps(this.itercps(e,n),{linelimit:r,mode:o,direction:s,usecurrentglyphspacing:a})}}class l{constructor(t,e){this.meta=t,this.font=e}toString(){return this.draw().toString()}repr(){var t;return"Glyph("+JSON.stringify(this.meta,null,2)+", Font(<"+(null===(t=this.font.headers)||void 0===t?void 0:t.fontname)+">)"}cp(){return this.meta.codepoint}chr(){return String.fromCodePoint(this.cp())}draw(t,e){const n=null!=e?e:null;let r;switch(null!=t?t:0){case 0:r=this.__draw_fbb();break;case 1:r=this.__draw_bb();break;case 2:r=this.__draw_original();break;case-1:if(null===n)throw new Error("Parameter bb in draw() method must be set when mode=-1");r=this.__draw_user_specified(n)}return r}__draw_user_specified(t){const e=this.meta.bbxoff,n=this.meta.bbyoff,[r,i,s,a]=t;return this.__draw_bb().crop(r,i,-e+s,-n+a)}__draw_original(){return new h(this.meta.hexdata.map((t=>t?parseInt(t,16).toString(2).padStart(4*t.length,"0"):"")))}__draw_bb(){const t=this.meta.bbw,e=this.meta.bbh,n=this.__draw_original(),r=n.bindata,i=r.length;return i!==e&&console.warn(`Glyph "${this.meta.glyphname.toString()}" (codepoint ${this.meta.codepoint.toString()})'s bbh, ${e.toString()}, does not match its hexdata line count, ${i.toString()}`),n.bindata=r.map((e=>e.slice(0,t))),n}__draw_fbb(){const t=this.font.headers;if(void 0===t)throw new Error("Font is not loaded");return this.__draw_user_specified([t.fbbx,t.fbby,t.fbbxoff,t.fbbyoff])}origin(t={}){var e,n,r,i;const s=null!==(e=t.mode)&&void 0!==e?e:0,a=null!==(n=t.fromorigin)&&void 0!==n&&n,o=null!==(r=t.xoff)&&void 0!==r?r:null,l=null!==(i=t.yoff)&&void 0!==i?i:null;let h;const c=this.meta.bbxoff,d=this.meta.bbyoff;switch(s){case 0:const t=this.font.headers;if(void 0===t)throw new Error("Font is not loaded");h=[t.fbbxoff,t.fbbyoff];break;case 1:case 2:h=[c,d];break;case-1:if(null===o||null===l)throw new Error("Parameter xoff and yoff in origin() method must be all set when mode=-1");h=[o,l]}return a?h:[0-h[0],0-h[1]]}}class h{constructor(t){this.bindata=t}toString(){return this.bindata.join("\n").replace(/0/g,".").replace(/1/g,"#").replace(/2/g,"&")}repr(){return`Bitmap(${JSON.stringify(this.bindata,null,2)})`}width(){return this.bindata[0].length}height(){return this.bindata.length}clone(){return new h([...this.bindata])}static __crop_string(t,e,n){let r=t;const i=t.length;let s=0;e<0&&(s=0-e,r=r.padStart(s+i,"0")),e+n>i&&(r=r.padEnd(e+n-i+r.length,"0"));const a=e+s;return r.slice(a,a+n)}static __string_offset_concat(t,e,n){const r=null!=n?n:0;if(0===r)return t+e;const i=t.length,s=i+r,a=s+e.length,o=Math.min(0,s),l=Math.max(i,a),c=h.__crop_string(t,o,l-o),d=h.__crop_string(e,o-s,l-o);return c.split("").map(((t,e)=>(parseInt(d[e],10)||parseInt(t,10)).toString())).join("")}static __listofstr_offset_concat(t,e,n){const r=null!=n?n:0;let i,s;if(0===r)return t.concat(e);const a=t[0].length,o=t.length,l=o+r,h=l+e.length,c=Math.min(0,l),d=Math.max(o,h),_=[];for(let n=c;n<d;n++)i=n<0||n>=o?"0".repeat(a):t[n],s=n<l||n>=h?"0".repeat(a):e[n-l],_.push(i.split("").map(((t,e)=>(parseInt(s[e],10)||parseInt(t,10)).toString())).join(""));return _}static __crop_bitmap(t,e,n,r,i){let s;const a=[],o=t.length;for(let l=0;l<n;l++)s=o-i-n+l,s<0||s>=o?a.push("0".repeat(e)):a.push(h.__crop_string(t[s],r,e));return a}crop(t,e,n,r){const i=null!=n?n:0,s=null!=r?r:0;return this.bindata=h.__crop_bitmap(this.bindata,t,e,i,s),this}overlay(t){const e=this.bindata,n=t.bindata;return e.length!==n.length&&console.warn("the bitmaps to overlay have different height"),e[0].length!==n[0].length&&console.warn("the bitmaps to overlay have different width"),this.bindata=e.map(((t,e)=>{const r=t,i=n[e];return r.split("").map(((t,e)=>(parseInt(i[e],10)||parseInt(t,10)).toString())).join("")})),this}static concatall(t,e={}){var n,r,i;const s=null!==(n=e.direction)&&void 0!==n?n:1,a=null!==(r=e.align)&&void 0!==r?r:1,o=null!==(i=e.offsetlist)&&void 0!==i?i:null;let l,c,d,_,p,u,f;if(s>0){d=Math.max(...t.map((t=>t.height()))),p=Array(d).fill("");const e=(t,e,n)=>1===s?h.__string_offset_concat(t,e,n):h.__string_offset_concat(e,t,n);for(let n=0;n<d;n++){c=a?-n-1:n,_=0;const r=t.length;for(let i=0;i<r;i++){const r=t[i];o&&0!==i&&(_=o[i-1]),n<r.height()?c>=0?p[c]=e(p[c],r.bindata[c],_):p[d+c]=e(p[d+c],r.bindata[r.height()+c],_):c>=0?p[c]=e(p[c],"0".repeat(r.width()),_):p[d+c]=e(p[d+c],"0".repeat(r.width()),_)}}}else{d=Math.max(...t.map((t=>t.width()))),p=[],_=0;const e=t.length;for(let n=0;n<e;n++){const e=t[n];o&&0!==n&&(_=o[n-1]),l=e.bindata,u=e.width(),u!==d&&(f=a?0:u-d,l=this.__crop_bitmap(l,d,e.height(),f,0)),p=0===s?h.__listofstr_offset_concat(p,l,_):h.__listofstr_offset_concat(l,p,_)}}return new this(p)}concat(t,e={}){const{direction:n,align:r,offset:i}=e,s=null!=i?i:0;return this.bindata=h.concatall([this,t],{direction:n,align:r,offsetlist:[s]}).bindata,this}static __enlarge_bindata(t,e,n){const r=null!=e?e:1,i=null!=n?n:1;let s=[...t];return r>1&&(s=s.map((t=>t.split("").reduce(((t,e)=>t.concat(Array(r).fill(e))),[]).join("")))),i>1&&(s=s.reduce(((t,e)=>t.concat(Array(i).fill(e))),[])),s}enlarge(t,e){return this.bindata=h.__enlarge_bindata(this.bindata,t,e),this}replace(t,e){const n="number"==typeof t?t.toString():t,r="number"==typeof e?e.toString():e;return this.bindata=this.bindata.map((t=>((t,e,n)=>{if("replaceAll"in String.prototype)return t.replaceAll(e,n);{const r=t=>t.replace(/[.*+\-?^${}()|[\]\\]/g,"\\$&");return t.replace(new RegExp(r(e),"g"),n)}})(t,n,r))),this}shadow(t,e){const n=null!=t?t:1,r=null!=e?e:-1;let i,s,a,o,l,h;const c=this.clone();return h=this.width(),i=this.height(),h+=Math.abs(n),i+=Math.abs(r),c.bindata=c.bindata.map((t=>t.replace(/1/g,"2"))),n>0?(s=0,o=-n):(s=n,o=0),r>0?(a=0,l=-r):(a=r,l=0),this.crop(h,i,s,a),c.crop(h,i,o,l),c.overlay(this),this.bindata=c.bindata,this}glow(t){var e,n,r,i,s,a,o,l,h,c,d,_,p,u;const f=null!=t?t:0;let b,y,g,v;g=this.width(),v=this.height(),g+=2,v+=2,this.crop(g,v,-1,-1);const w=this.todata(2),m=w.length;for(let t=0;t<m;t++){b=w[t];const g=b.length;for(let v=0;v<g;v++)y=b[v],1===y&&((e=w[t])[n=v-1]||(e[n]=2),(r=w[t])[i=v+1]||(r[i]=2),(s=w[t-1])[v]||(s[v]=2),(a=w[t+1])[v]||(a[v]=2),1===f&&((o=w[t-1])[l=v-1]||(o[l]=2),(h=w[t-1])[c=v+1]||(h[c]=2),(d=w[t+1])[_=v-1]||(d[_]=2),(p=w[t+1])[u=v+1]||(p[u]=2)))}return this.bindata=w.map((t=>t.map((t=>t.toString())).join(""))),this}bytepad(t){const e=null!=t?t:8,n=this.width(),r=this.height(),i=n%e;return 0===i?this:this.crop(n+e-i,r)}todata(t){let e;switch(null!=t?t:1){case 0:e=this.bindata.join("\n");break;case 1:e=this.bindata;break;case 2:e=this.bindata.map((t=>t.split("").map((t=>parseInt(t,10)))));break;case 3:e=[].concat(...this.todata(2));break;case 4:e=this.bindata.map((t=>{if(!/^[01]+$/.test(t))throw new Error(`Invalid binary string: ${t}`);return parseInt(t,2).toString(16).padStart(-1*Math.floor(-1*this.width()/4),"0")}));break;case 5:e=this.bindata.map((t=>{if(!/^[01]+$/.test(t))throw new Error(`Invalid binary string: ${t}`);return parseInt(t,2)}))}return e}draw2canvas(t,e){const n=null!=e?e:{0:null,1:"black",2:"red"};return this.todata(2).forEach(((e,r)=>{e.forEach(((e,i)=>{const s=e.toString();if("0"===s||"1"===s||"2"===s){const e=n[s];null!=e&&(t.fillStyle=e,t.fillRect(i,r,1,1))}}))})),this}}const $Font=e=>t(void 0,void 0,void 0,(function*(){return yield(new o).load_filelines(e)})),$Glyph=(t,e)=>new l(t,e),$Bitmap=t=>new h(t);

// Export for ES modules
export { $Font, $Glyph, $Bitmap, $fetchline, o as Font, l as Glyph, h as Bitmap };
