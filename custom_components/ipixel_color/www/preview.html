<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>iPIXEL Cards Preview</title>
  <style>
    :root {
      --primary-color: #03a9f4;
      --primary-text-color: #fff;
      --secondary-text-color: rgba(255,255,255,0.7);
      --card-background-color: #1c1c1c;
      --ha-card-background: #1c1c1c;
    }

    * {
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
      background: #111;
      color: #fff;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }

    .header {
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 20px;
      border-bottom: 1px solid #333;
    }

    .header h1 {
      margin: 0 0 8px 0;
      font-size: 1.8em;
      font-weight: 500;
    }

    .header p {
      margin: 0;
      color: rgba(255,255,255,0.6);
      font-size: 0.9em;
    }

    .preview-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
      gap: 20px;
      max-width: 1400px;
      margin: 0 auto;
    }

    .card-wrapper {
      background: #1a1a1a;
      border-radius: 12px;
      padding: 16px;
    }

    .card-label {
      font-size: 0.75em;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: rgba(255,255,255,0.5);
      margin-bottom: 12px;
    }

    /* Mock ha-card styles */
    ha-card {
      display: block;
      background: var(--card-background-color);
      border-radius: 12px;
      overflow: hidden;
    }

    .controls-section {
      background: #1a1a1a;
      border-radius: 12px;
      padding: 20px;
      margin-top: 30px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .controls-section h3 {
      margin: 0 0 16px 0;
      font-size: 1em;
      font-weight: 500;
      color: rgba(255,255,255,0.8);
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 12px;
    }

    .control-row label {
      min-width: 100px;
      font-size: 0.85em;
      color: rgba(255,255,255,0.7);
    }

    .control-row input[type="number"],
    .control-row select {
      flex: 1;
      padding: 8px 12px;
      border: 1px solid #333;
      border-radius: 6px;
      background: #222;
      color: #fff;
      font-size: 0.9em;
    }

    .control-row button {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background: var(--primary-color);
      color: #fff;
      cursor: pointer;
      font-size: 0.9em;
    }

    .control-row button:hover {
      background: #0288d1;
    }

    .log-section {
      background: #0a0a0a;
      border-radius: 8px;
      padding: 16px;
      margin-top: 30px;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .log-section h3 {
      margin: 0 0 12px 0;
      font-size: 0.9em;
      color: rgba(255,255,255,0.6);
    }

    #service-log {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.8em;
      color: #0f0;
      max-height: 200px;
      overflow-y: auto;
    }

    #service-log .log-entry {
      padding: 4px 0;
      border-bottom: 1px solid #222;
    }

    #service-log .log-time {
      color: #666;
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>iPIXEL Cards Preview</h1>
    <p>Development preview - test cards without Home Assistant</p>

    <div class="controls-section" id="ble-section" style="margin-top: 20px; text-align: left;">
      <h3>Real Device Connection (WebBluetooth)</h3>
      <div class="control-row">
        <label>Status:</label>
        <span id="ble-status" style="color: #f44; font-weight: bold;">Disconnected</span>
        <span id="ble-device-name" style="color: #888; margin-left: 8px;"></span>
      </div>
      <div class="control-row">
        <button id="ble-connect-btn" onclick="connectBleDevice()">Connect Device</button>
        <button id="ble-disconnect-btn" onclick="disconnectBleDevice()" style="display:none;">Disconnect</button>
      </div>
      <div class="control-row" id="ble-controls" style="display:none;">
        <button onclick="blePowerOn()">Power On</button>
        <button onclick="blePowerOff()">Power Off</button>
        <button onclick="bleSendPreview()">Send Preview to Device</button>
      </div>
      <div class="control-row" id="ble-controls-debug" style="display:none;">
        <button onclick="bleTestPattern()" style="background:#f80;">Test 3px</button>
        <button onclick="bleTestCamera()" style="background:#f0f;">Test Cam</button>
        <button onclick="bleSendCamera()" style="background:#0a0;">Camera (Fast)</button>
        <button onclick="bleSendDiyPixels()" style="background:#888;">DIY (Slow)</button>
        <button onclick="debugRenderer()" style="background:#08f;">Debug</button>
        <button onclick="bleResetLock()" style="background:#f00;">Reset</button>
      </div>
      <div class="control-row" id="ble-controls-stream" style="display:none;">
        <button id="ble-stream-btn" onclick="bleToggleStream()" style="background:#0aa; min-width: 140px;">▶ Stream to Device</button>
        <label style="margin-left: 8px;">FPS:</label>
        <select id="ble-stream-fps">
          <option value="2">2 (Slow)</option>
          <option value="3" selected>3 (Default)</option>
          <option value="5">5 (Fast)</option>
          <option value="8">8 (Very Fast)</option>
        </select>
        <span id="ble-stream-status" style="margin-left: 8px; color: #888;"></span>
      </div>
      <div class="control-row" id="ble-controls-2" style="display:none;">
        <label>Brightness:</label>
        <input type="range" id="ble-brightness" min="1" max="100" value="50" style="flex:1;">
        <span id="ble-brightness-value">50</span>
        <button onclick="bleSetBrightness()">Set</button>
      </div>
      <div class="control-row" id="ble-controls-3" style="display:none;">
        <label>Clock:</label>
        <select id="ble-clock-style">
          <option value="1">Style 1</option>
          <option value="2">Style 2</option>
          <option value="3">Style 3</option>
          <option value="4">Style 4</option>
          <option value="5">Style 5</option>
          <option value="6">Style 6</option>
          <option value="7">Style 7</option>
          <option value="8">Style 8</option>
        </select>
        <button onclick="bleSetClockMode()">Show Clock</button>
        <button onclick="bleSyncTime()">Sync Time</button>
      </div>
      <div class="control-row" id="ble-controls-4" style="display:none;">
        <label>Orientation:</label>
        <select id="ble-orientation">
          <option value="0">Normal</option>
          <option value="1">Upside Down</option>
        </select>
        <button onclick="bleSetOrientation()">Set</button>
        <button onclick="bleClearDisplay()">Clear</button>
      </div>
      <div class="control-row" id="ble-controls-5" style="display:none;">
        <label>Rainbow:</label>
        <select id="ble-rainbow-mode">
          <option value="0">None</option>
          <option value="1">Wave</option>
          <option value="2">Cycle</option>
          <option value="3">Pulse</option>
          <option value="4">Fade</option>
          <option value="5">Chase</option>
          <option value="6">Sparkle</option>
          <option value="7">Gradient</option>
          <option value="8">Theater</option>
          <option value="9">Fire</option>
        </select>
        <button onclick="bleSetRainbowMode()">Set Rainbow</button>
      </div>
      <div class="control-row" id="ble-controls-6" style="display:none;">
        <label>Rhythm:</label>
        <select id="ble-rhythm-style">
          <option value="0">Classic Bars</option>
          <option value="1">Mirrored Bars</option>
          <option value="2">Center Out</option>
          <option value="3">Wave Style</option>
          <option value="4">Particle Style</option>
        </select>
        <button onclick="bleSetRhythmDemo()">Demo Rhythm</button>
      </div>
      <p style="font-size: 0.75em; color: #666; margin-top: 8px;">
        Requires Chrome or Edge. Click "Connect Device" and select your LED_BLE_* device.
      </p>
    </div>
  </div>

  <div class="preview-container">
    <div class="card-wrapper">
      <div class="card-label">Display Card</div>
      <ipixel-display-card id="display-card"></ipixel-display-card>
    </div>

    <div class="card-wrapper">
      <div class="card-label">Text Card</div>
      <ipixel-text-card id="text-card"></ipixel-text-card>
    </div>

    <div class="card-wrapper">
      <div class="card-label">Controls Card</div>
      <ipixel-controls-card id="controls-card"></ipixel-controls-card>
    </div>

    <div class="card-wrapper">
      <div class="card-label">Playlist Card</div>
      <ipixel-playlist-card id="playlist-card"></ipixel-playlist-card>
    </div>

    <div class="card-wrapper">
      <div class="card-label">Schedule Card</div>
      <ipixel-schedule-card id="schedule-card"></ipixel-schedule-card>
    </div>

    <div class="card-wrapper">
      <div class="card-label">Editor Card</div>
      <ipixel-editor-card id="editor-card"></ipixel-editor-card>
    </div>
  </div>

  <div class="controls-section">
    <h3>Preview Settings</h3>
    <div class="control-row">
      <label>Width:</label>
      <input type="number" id="preview-width" value="64" min="16" max="256">
      <label>Height:</label>
      <input type="number" id="preview-height" value="16" min="8" max="64">
      <button onclick="updateResolution()">Apply</button>
    </div>
    <div class="control-row">
      <label>Power:</label>
      <select id="preview-power">
        <option value="on">On</option>
        <option value="off">Off</option>
      </select>
      <button onclick="togglePower()">Toggle</button>
    </div>
  </div>

  <div class="log-section">
    <h3>Service Calls Log</h3>
    <div id="service-log"></div>
  </div>

  <script type="module">
    // Mock Home Assistant API
    const mockStates = {
      'switch.ipixel_preview': {
        state: 'on',
        entity_id: 'switch.ipixel_preview',
        attributes: { friendly_name: 'iPIXEL Preview' }
      },
      'text.ipixel_preview_text_display': {
        state: 'Hello',
        entity_id: 'text.ipixel_preview_text_display',
        attributes: { friendly_name: 'iPIXEL Text' }
      },
      'sensor.ipixel_preview_width': {
        state: '64',
        entity_id: 'sensor.ipixel_preview_width',
        attributes: { friendly_name: 'Display Width' }
      },
      'sensor.ipixel_preview_height': {
        state: '16',
        entity_id: 'sensor.ipixel_preview_height',
        attributes: { friendly_name: 'Display Height' }
      },
      'select.ipixel_preview_mode': {
        state: 'text',
        entity_id: 'select.ipixel_preview_mode',
        attributes: {
          friendly_name: 'Display Mode',
          options: ['text', 'textimage', 'clock', 'gif', 'rhythm']
        }
      },
      'number.ipixel_preview_brightness': {
        state: '50',
        entity_id: 'number.ipixel_preview_brightness',
        attributes: {
          friendly_name: 'Brightness',
          min: 1,
          max: 100
        }
      },
      'switch.ipixel_preview_upside_down': {
        state: 'off',
        entity_id: 'switch.ipixel_preview_upside_down',
        attributes: { friendly_name: 'Upside Down' }
      }
    };

    // Service log
    function logService(domain, service, data) {
      const logEl = document.getElementById('service-log');
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-time">${time}</span>${domain}.${service}: ${JSON.stringify(data)}`;
      logEl.insertBefore(entry, logEl.firstChild);

      // Keep only last 20 entries
      while (logEl.children.length > 20) {
        logEl.removeChild(logEl.lastChild);
      }
    }

    // Mock hass object
    const mockHass = {
      states: mockStates,
      callService: async (domain, service, data) => {
        console.log(`Service call: ${domain}.${service}`, data);
        logService(domain, service, data);

        // Handle some services
        if (domain === 'switch' && service === 'toggle') {
          const entityId = data.entity_id;
          if (mockStates[entityId]) {
            mockStates[entityId].state = mockStates[entityId].state === 'on' ? 'off' : 'on';
            updateCards();
          }
        }
        if (domain === 'text' && service === 'set_value') {
          const entityId = data.entity_id;
          if (mockStates[entityId]) {
            mockStates[entityId].state = data.value;
          }
        }

        // Forward iPIXEL service calls to BLE device when connected
        if (domain === 'ipixel_color' && BLE.isDeviceConnected()) {
          try {
            if (service === 'display_text') {
              // Wait for the display to update before sending pixels
              // The updateDisplayState event needs time to propagate
              logService('ble', 'forwarding_display_text', data);
              await new Promise(r => requestAnimationFrame(() => requestAnimationFrame(r)));
              await bleSendPreview();
            } else if (service === 'set_rhythm_level') {
              await BLE.setRhythmLevelMode(data.style, data.levels);
              logService('ble', 'set_rhythm_level', data);
            } else if (service === 'set_rainbow_mode') {
              await BLE.setRainbowMode(data.mode);
              logService('ble', 'set_rainbow_mode', data);
            }
          } catch (e) {
            logService('ble', 'error', { message: e.message });
          }
        }

        return Promise.resolve();
      },
      callWS: (msg) => {
        console.log('WebSocket call:', msg);
        return Promise.resolve({});
      },
      connection: {
        subscribeEvents: () => Promise.resolve(() => {}),
      },
      language: 'en',
      locale: { language: 'en' }
    };

    // Update resolution
    window.updateResolution = function() {
      const width = document.getElementById('preview-width').value;
      const height = document.getElementById('preview-height').value;
      mockStates['sensor.ipixel_preview_width'].state = width;
      mockStates['sensor.ipixel_preview_height'].state = height;

      // Clear cached resolution
      localStorage.removeItem('iPIXEL_Resolution');
      localStorage.setItem('iPIXEL_Resolution', JSON.stringify([parseInt(width), parseInt(height)]));

      updateCards();
      logService('preview', 'set_resolution', { width, height });
    };

    // Toggle power
    window.togglePower = function() {
      const powerSelect = document.getElementById('preview-power');
      const newState = powerSelect.value === 'on' ? 'off' : 'on';
      powerSelect.value = newState;
      mockStates['switch.ipixel_preview'].state = newState;
      updateCards();
      logService('switch', 'toggle', { entity_id: 'switch.ipixel_preview' });
    };

    // Update all cards
    function updateCards() {
      document.querySelectorAll('ipixel-display-card, ipixel-text-card, ipixel-controls-card, ipixel-playlist-card, ipixel-schedule-card, ipixel-editor-card').forEach(card => {
        if (card.hass !== undefined) {
          card.hass = { ...mockHass };
        }
      });
    }

    // Import BLE device module
    import * as BLE from './src/ble-device.js';
    window.BLE = BLE; // Expose for debugging

    // BLE connection functions
    window.connectBleDevice = async function() {
      try {
        const deviceName = await BLE.connectDevice();
        document.getElementById('ble-status').textContent = 'Connected';
        document.getElementById('ble-status').style.color = '#4f4';
        document.getElementById('ble-device-name').textContent = deviceName;
        document.getElementById('ble-connect-btn').style.display = 'none';
        document.getElementById('ble-disconnect-btn').style.display = 'inline-block';
        document.getElementById('ble-controls').style.display = 'flex';
        document.getElementById('ble-controls-debug').style.display = 'flex';
        document.getElementById('ble-controls-stream').style.display = 'flex';
        document.getElementById('ble-controls-2').style.display = 'flex';
        document.getElementById('ble-controls-3').style.display = 'flex';
        document.getElementById('ble-controls-4').style.display = 'flex';
        document.getElementById('ble-controls-5').style.display = 'flex';
        document.getElementById('ble-controls-6').style.display = 'flex';

        // Auto-detect and set device dimensions from device name
        const dimensions = BLE.getDeviceDimensions();
        if (dimensions) {
          document.getElementById('preview-width').value = dimensions.width;
          document.getElementById('preview-height').value = dimensions.height;
          updateResolution();
          logService('ble', 'auto_dimensions', dimensions);
        }

        logService('ble', 'connect', { device: deviceName });
      } catch (e) {
        logService('ble', 'error', { message: e.message });
      }
    };

    window.disconnectBleDevice = async function() {
      await BLE.disconnectDevice();
      document.getElementById('ble-status').textContent = 'Disconnected';
      document.getElementById('ble-status').style.color = '#f44';
      document.getElementById('ble-device-name').textContent = '';
      document.getElementById('ble-connect-btn').style.display = 'inline-block';
      document.getElementById('ble-disconnect-btn').style.display = 'none';
      document.getElementById('ble-controls').style.display = 'none';
      document.getElementById('ble-controls-debug').style.display = 'none';
      document.getElementById('ble-controls-stream').style.display = 'none';
      document.getElementById('ble-controls-2').style.display = 'none';
      document.getElementById('ble-controls-3').style.display = 'none';
      document.getElementById('ble-controls-4').style.display = 'none';
      document.getElementById('ble-controls-5').style.display = 'none';
      document.getElementById('ble-controls-6').style.display = 'none';
      // Stop streaming on disconnect
      if (BLE.isAnimationRunning()) {
        BLE.stopAnimation();
        updateStreamButton(false);
      }
      logService('ble', 'disconnect', {});
    };

    window.blePowerOn = async function() {
      await BLE.powerOn();
      logService('ble', 'power_on', {});
    };

    window.blePowerOff = async function() {
      await BLE.powerOff();
      logService('ble', 'power_off', {});
    };

    window.bleSetBrightness = async function() {
      const value = parseInt(document.getElementById('ble-brightness').value);
      await BLE.setBrightness(value);
      logService('ble', 'set_brightness', { value });
    };

    window.bleSetClockMode = async function() {
      const style = parseInt(document.getElementById('ble-clock-style').value);
      await BLE.setClockMode(style, true, false);
      logService('ble', 'set_clock_mode', { style });
    };

    window.bleSyncTime = async function() {
      await BLE.syncTime();
      logService('ble', 'sync_time', {});
    };

    window.bleSetOrientation = async function() {
      const orientation = parseInt(document.getElementById('ble-orientation').value);
      await BLE.setOrientation(orientation);
      logService('ble', 'set_orientation', { orientation });
    };

    window.bleClearDisplay = async function() {
      await BLE.enterDiyMode();
      logService('ble', 'clear_display', {});
    };

    window.bleSetRainbowMode = async function() {
      const mode = parseInt(document.getElementById('ble-rainbow-mode').value);
      await BLE.setRainbowMode(mode);
      logService('ble', 'set_rainbow_mode', { mode });
    };

    window.bleSetRhythmDemo = async function() {
      const style = parseInt(document.getElementById('ble-rhythm-style').value);
      // Send a demo rhythm with random levels
      const levels = Array.from({length: 11}, () => Math.floor(Math.random() * 16));
      await BLE.setRhythmLevelMode(style, levels);
      logService('ble', 'set_rhythm_level', { style, levels });
    };

    // Update brightness display and auto-send on change
    document.getElementById('ble-brightness').addEventListener('input', (e) => {
      document.getElementById('ble-brightness-value').textContent = e.target.value;
    });

    // Auto-send brightness when slider stops (on change)
    document.getElementById('ble-brightness').addEventListener('change', (e) => {
      if (BLE.isDeviceConnected()) {
        bleSetBrightness();
      }
    });

    // Auto-send clock style on change (but not while sending pixels)
    document.getElementById('ble-clock-style').addEventListener('change', (e) => {
      if (BLE.isDeviceConnected() && !isSendingPixels) {
        bleSetClockMode();
      }
    });

    // Auto-send orientation on change
    document.getElementById('ble-orientation').addEventListener('change', (e) => {
      if (BLE.isDeviceConnected() && !isSendingPixels) {
        bleSetOrientation();
      }
    });

    // Auto-send rainbow mode on change
    document.getElementById('ble-rainbow-mode').addEventListener('change', (e) => {
      if (BLE.isDeviceConnected() && !isSendingPixels) {
        bleSetRainbowMode();
      }
    });

    // Auto-send rhythm style on change
    document.getElementById('ble-rhythm-style').addEventListener('change', (e) => {
      if (BLE.isDeviceConnected() && !isSendingPixels) {
        bleSetRhythmDemo();
      }
    });

    // Flag to prevent mode changes while sending pixels
    let isSendingPixels = false;

    // Helper function to get pixels from renderer
    // Ambient effects write to buffer (RGB arrays), text effects write to _colorPixels (hex strings)
    function getRendererPixels(renderer) {
      // Check if buffer has RGB data from ambient effects
      if (renderer.buffer && renderer.buffer.length > 0) {
        const firstPixel = renderer.buffer[0];
        // If buffer contains RGB arrays, convert to hex strings
        if (Array.isArray(firstPixel) && firstPixel.length >= 3) {
          return renderer.buffer.map(rgb => {
            if (Array.isArray(rgb) && rgb.length >= 3) {
              const r = Math.floor(rgb[0]).toString(16).padStart(2, '0');
              const g = Math.floor(rgb[1]).toString(16).padStart(2, '0');
              const b = Math.floor(rgb[2]).toString(16).padStart(2, '0');
              return `#${r}${g}${b}`;
            }
            return '#000000';
          });
        }
      }
      // Fallback to _colorPixels (for text effects)
      return renderer._colorPixels || [];
    }

    window.bleSendPreview = async function() {
      // Get current preview pixels from the renderer
      const displayCard = document.getElementById('display-card');
      if (!displayCard || !displayCard._renderer) {
        logService('ble', 'error', { message: 'No renderer available' });
        return;
      }

      const renderer = displayCard._renderer;
      const width = renderer.width;
      const height = renderer.height;
      const pixels = getRendererPixels(renderer);

      // Find actual non-black pixels with their positions
      const nonBlackPixels = [];
      for (let i = 0; i < pixels.length; i++) {
        const p = pixels[i];
        if (p && p !== '#000000' && p !== '#000' && p !== '#111' && p !== '#111111' && p !== '#050505') {
          const x = i % width;
          const y = Math.floor(i / width);
          nonBlackPixels.push({ idx: i, x, y, color: p });
        }
      }

      if (pixels.length === 0) {
        logService('ble', 'error', { message: 'No pixels to send' });
        return;
      }

      logService('ble', 'send_preview', {
        width,
        height,
        pixelCount: pixels.length,
        nonBlackCount: nonBlackPixels.length,
        firstFewColoredPixels: nonBlackPixels.slice(0, 5)
      });

      if (nonBlackPixels.length === 0) {
        logService('ble', 'warning', { message: 'No colored pixels to send - all black!' });
        return;
      }

      try {
        isSendingPixels = true;
        // Use TYPE_CAMERA protocol (fastest method from go-ipxl)
        await BLE.sendImageCamera(pixels, width, height);
        logService('ble', 'send_preview_complete', { sentPixels: nonBlackPixels.length, method: 'camera' });
      } catch (e) {
        logService('ble', 'error', { message: e.message });
      } finally {
        isSendingPixels = false;
      }
    };

    // Debug function to test BLE with a simple pattern
    window.bleTestPattern = async function() {
      if (!BLE.isDeviceConnected()) {
        logService('ble', 'error', { message: 'Not connected' });
        return;
      }

      logService('ble', 'test_pattern', { message: 'Sending test pattern (3 pixels)...' });

      try {
        // Enter DIY mode
        logService('ble', 'test', { step: 'Entering DIY mode...' });
        await BLE.enterDiyMode();
        await new Promise(r => setTimeout(r, 300));

        // Just send 3 pixels with longer delays
        logService('ble', 'test', { step: 'Sending red pixel at (0,0)...' });
        await BLE.setPixel(0, 0, 255, 0, 0);
        await new Promise(r => setTimeout(r, 150));

        logService('ble', 'test', { step: 'Sending green pixel at (1,0)...' });
        await BLE.setPixel(1, 0, 0, 255, 0);
        await new Promise(r => setTimeout(r, 150));

        logService('ble', 'test', { step: 'Sending blue pixel at (2,0)...' });
        await BLE.setPixel(2, 0, 0, 0, 255);
        await new Promise(r => setTimeout(r, 150));

        logService('ble', 'test_pattern_complete', { message: 'Test pattern sent! You should see R-G-B pixels at top-left.' });
      } catch (e) {
        logService('ble', 'error', { message: e.message, stack: e.stack });
      }
    };

    // Test single pixel
    window.bleTestSinglePixel = async function() {
      if (!BLE.isDeviceConnected()) {
        logService('ble', 'error', { message: 'Not connected' });
        return;
      }

      try {
        logService('ble', 'test', { step: 'Entering DIY mode...' });
        await BLE.enterDiyMode();
        await new Promise(r => setTimeout(r, 300));

        logService('ble', 'test', { step: 'Sending single white pixel at (5,5)...' });
        await BLE.setPixel(5, 5, 255, 255, 255);

        logService('ble', 'test_complete', { message: 'Single pixel sent! Look for white pixel at (5,5).' });
      } catch (e) {
        logService('ble', 'error', { message: e.message });
      }
    };

    // Test camera protocol with simple gradient pattern
    window.bleTestCamera = async function() {
      if (!BLE.isDeviceConnected()) {
        logService('ble', 'error', { message: 'Not connected' });
        return;
      }

      logService('ble', 'test_camera', { message: 'Testing TYPE_CAMERA protocol...' });

      try {
        await BLE.testCameraProtocol();
        logService('ble', 'test_camera_complete', { message: 'Camera test sent! You should see a red gradient on the left side.' });
      } catch (e) {
        logService('ble', 'error', { message: e.message, stack: e.stack });
      }
    };

    // Update stream button appearance
    function updateStreamButton(isStreaming) {
      const btn = document.getElementById('ble-stream-btn');
      const status = document.getElementById('ble-stream-status');
      if (isStreaming) {
        btn.textContent = '⏹ Stop Stream';
        btn.style.background = '#a00';
        status.textContent = 'Streaming...';
        status.style.color = '#4f4';
      } else {
        btn.textContent = '▶ Stream to Device';
        btn.style.background = '#0aa';
        status.textContent = '';
      }
    }

    // Toggle animation streaming to device
    window.bleToggleStream = async function() {
      if (!BLE.isDeviceConnected()) {
        logService('ble', 'error', { message: 'Not connected' });
        return;
      }

      // If already streaming, stop it
      if (BLE.isAnimationRunning()) {
        BLE.stopAnimation();
        updateStreamButton(false);
        logService('ble', 'stream_stopped', { message: 'Animation streaming stopped' });
        return;
      }

      // Get the renderer
      const displayCard = document.getElementById('display-card');
      if (!displayCard || !displayCard._renderer) {
        logService('ble', 'error', { message: 'No renderer available' });
        return;
      }

      const renderer = displayCard._renderer;
      const width = renderer.width;
      const height = renderer.height;
      const fps = parseInt(document.getElementById('ble-stream-fps').value) || 3;

      logService('ble', 'stream_starting', { width, height, fps });

      // Function to get current frame pixels (uses helper that handles both buffer and _colorPixels)
      const getFramePixels = () => getRendererPixels(renderer);

      try {
        updateStreamButton(true);
        await BLE.streamAnimation(getFramePixels, width, height, fps);
      } catch (e) {
        logService('ble', 'stream_error', { message: e.message });
        updateStreamButton(false);
      }
    };

    // Reset BLE lock if it gets stuck
    window.bleResetLock = function() {
      BLE.resetBleLock();
      logService('ble', 'lock_reset', { message: 'BLE lock has been reset' });
    };

    // Send using TYPE_CAMERA protocol (fastest, from go-ipxl)
    window.bleSendCamera = async function() {
      if (!BLE.isDeviceConnected()) {
        logService('ble', 'error', { message: 'Not connected' });
        return;
      }

      const displayCard = document.getElementById('display-card');
      if (!displayCard || !displayCard._renderer) {
        logService('ble', 'error', { message: 'No renderer available' });
        return;
      }

      const renderer = displayCard._renderer;
      const width = renderer.width;
      const height = renderer.height;
      const pixels = getRendererPixels(renderer);

      if (pixels.length === 0) {
        logService('ble', 'error', { message: 'No pixels to send' });
        return;
      }

      logService('ble', 'send_camera', { width, height, pixelCount: pixels.length });

      try {
        isSendingPixels = true;
        await BLE.sendImageCamera(pixels, width, height);
        logService('ble', 'send_camera_complete', { message: 'Camera image sent!' });
      } catch (e) {
        logService('ble', 'error', { message: e.message });
      } finally {
        isSendingPixels = false;
      }
    };

    // Send using old DIY pixel-by-pixel mode (slower but known to work)
    window.bleSendDiyPixels = async function() {
      if (!BLE.isDeviceConnected()) {
        logService('ble', 'error', { message: 'Not connected' });
        return;
      }

      const displayCard = document.getElementById('display-card');
      if (!displayCard || !displayCard._renderer) {
        logService('ble', 'error', { message: 'No renderer available' });
        return;
      }

      const renderer = displayCard._renderer;
      const width = renderer.width;
      const height = renderer.height;
      const pixels = getRendererPixels(renderer);

      if (pixels.length === 0) {
        logService('ble', 'error', { message: 'No pixels to send' });
        return;
      }

      logService('ble', 'send_diy_pixels', { width, height, pixelCount: pixels.length });

      try {
        isSendingPixels = true;
        await BLE.sendPixels(pixels, width, height);
        logService('ble', 'send_diy_complete', { message: 'DIY pixels sent!' });
      } catch (e) {
        logService('ble', 'error', { message: e.message });
      } finally {
        isSendingPixels = false;
      }
    };

    // Debug function to check renderer state
    window.debugRenderer = function() {
      const displayCard = document.getElementById('display-card');
      const renderer = displayCard?._renderer;

      if (!renderer) {
        console.log('No renderer found');
        logService('debug', 'renderer', { error: 'No renderer found' });
        return;
      }

      const info = {
        width: renderer.width,
        height: renderer.height,
        pixelCount: renderer._colorPixels?.length || 0,
        extendedWidth: renderer.extendedWidth,
        effect: renderer._currentEffect,
        container: !!renderer._container
      };

      // Sample some pixels
      const pixels = getRendererPixels(renderer);
      const nonBlack = pixels.filter(p => p && p !== '#000000' && p !== '#000' && p !== '#111' && p !== '#111111');
      info.nonBlackPixels = nonBlack.length;
      info.sampleNonBlack = nonBlack.slice(0, 5);

      console.log('Renderer state:', info);
      logService('debug', 'renderer', info);
      return info;
    };

    // Handle BLE disconnect events
    BLE.addEventListener('disconnect', () => {
      document.getElementById('ble-status').textContent = 'Disconnected';
      document.getElementById('ble-status').style.color = '#f44';
      document.getElementById('ble-device-name').textContent = '';
      document.getElementById('ble-connect-btn').style.display = 'inline-block';
      document.getElementById('ble-disconnect-btn').style.display = 'none';
      document.getElementById('ble-controls').style.display = 'none';
      document.getElementById('ble-controls-debug').style.display = 'none';
      document.getElementById('ble-controls-stream').style.display = 'none';
      document.getElementById('ble-controls-2').style.display = 'none';
      document.getElementById('ble-controls-3').style.display = 'none';
      document.getElementById('ble-controls-4').style.display = 'none';
      document.getElementById('ble-controls-5').style.display = 'none';
      document.getElementById('ble-controls-6').style.display = 'none';
      // Stop streaming on disconnect
      if (BLE.isAnimationRunning()) {
        BLE.stopAnimation();
        updateStreamButton(false);
      }
    });

    // Check WebBluetooth availability
    if (!BLE.isWebBluetoothAvailable()) {
      document.getElementById('ble-section').innerHTML = `
        <h3>Real Device Connection</h3>
        <p style="color: #f88;">WebBluetooth is not available. Use Chrome or Edge on a supported platform.</p>
      `;
    }

    // Import and initialize cards
    import('./src/index.js').then(() => {
      console.log('iPIXEL Cards loaded');

      // Configure cards
      const displayCard = document.getElementById('display-card');
      const textCard = document.getElementById('text-card');
      const controlsCard = document.getElementById('controls-card');
      const playlistCard = document.getElementById('playlist-card');
      const scheduleCard = document.getElementById('schedule-card');
      const editorCard = document.getElementById('editor-card');

      // Set config
      const config = {
        entity: 'text.ipixel_preview_text_display',
        name: 'iPIXEL Preview'
      };

      displayCard.setConfig(config);
      textCard.setConfig(config);
      controlsCard.setConfig(config);
      playlistCard.setConfig(config);
      scheduleCard.setConfig(config);
      editorCard.setConfig(config);

      // Set hass
      displayCard.hass = mockHass;
      textCard.hass = mockHass;
      controlsCard.hass = mockHass;
      playlistCard.hass = mockHass;
      scheduleCard.hass = mockHass;
      editorCard.hass = mockHass;

      console.log('Cards initialized');
    }).catch(err => {
      console.error('Failed to load cards:', err);
      document.body.innerHTML += `<div style="color:red;padding:20px;">Error loading cards: ${err.message}</div>`;
    });
  </script>
</body>
</html>
